<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>The Moon - Live</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@200;300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #18263e; 
            --text-gold: #e3d4aa; 
            --accent-red: #d62828;
        }

        body {
            background-color: #0f1724;
            font-family: 'Oswald', sans-serif;
            height: 100dvh; /* Dynamic Viewport Height for mobile */
            width: 100vw;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            touch-action: pan-y; /* Enable vertical scrolling */
            -webkit-overflow-scrolling: touch;
        }

        #app-container {
            width: 100%;
            min-height: 100%;
            max-width: 430px; /* Max width for iPhone Pro Max style */
            background-color: var(--bg-color);
            color: var(--text-gold);
            position: relative;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: env(safe-area-inset-top, 40px) 20px env(safe-area-inset-bottom, 20px) 20px;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border: none; /* Remove border for full screen feel */
            flex-shrink: 0;
            -webkit-overflow-scrolling: touch;
        }

        h1 {
            font-weight: 400;
            letter-spacing: 0.05em;
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
            line-height: 1;
        }
        
        .phase-name {
            font-weight: 300;
            font-size: 1.2rem;
            opacity: 0.6;
            letter-spacing: 0.1em;
            margin-top: 0.5rem;
            text-transform: uppercase;
        }

        /* Compass System */
        .compass-wrapper {
            position: relative;
            width: 85%; 
            aspect-ratio: 1 / 1;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 1rem 0;
            perspective: 1000px;
        }

        .dial-rotator {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            transition: transform 0.05s linear;
            will-change: transform;
            /* Will be rotated by JS */
        }

        .viewfinder-static {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        .tick {
            position: absolute;
            left: 50%;
            top: 0;
            width: 2px; 
            height: 50%; 
            transform-origin: bottom center;
            z-index: 1;
            pointer-events: none;
        }
        
        .tick::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background-color: var(--text-gold); 
            box-shadow: 0 0 4px rgba(227, 212, 170, 0.3); 
        }

        .tick.major::after { height: 15%; width: 2px; }
        .tick.medium::after { height: 10%; width: 1px; opacity: 0.8; }
        .tick.minor::after { height: 5%; width: 1px; opacity: 0.5; }

        .dial-number {
            position: absolute;
            color: var(--text-gold);
            font-size: 0.9rem;
            font-weight: 400;
            text-align: center;
            width: 40px;
            margin-left: -20px;
            margin-top: -10px; /* Center vertically roughly */
            text-shadow: 0 1px 4px rgba(0,0,0,0.5);
        }

        /* Red Pointer restored */
        .red-pointer-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            transition: transform 0.3s ease-out;
            will-change: transform;
        }

        .red-pointer {
            position: absolute;
            top: 16%; 
            left: 50%;
            margin-left: -6px; 
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 10px solid var(--accent-red); 
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        /* Moon Visual Restored but centered correctly */
        .moon-visual {
            position: absolute;
            width: 35%;
            height: 35%;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 35%, #f0e6cc, #cbb885, #8a7d55);
            z-index: 10;
            box-shadow: 0 0 30px rgba(227, 212, 170, 0.15), inset -5px -5px 15px rgba(0,0,0,0.3);
        }
        
        /* --- 核心对齐修正 --- */
        .footer-stat-container {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-start; 
            gap: 1rem;
            position: relative;
        }

        .big-number-box {
            font-size: 8.5rem; 
            line-height: 0.7;  
            color: var(--text-gold);
            font-weight: 400;
            transform: translateY(-2px);
        }

        .stat-text-col {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            text-align: right;
            height: 5.8rem; 
            margin-top: 0.2rem; 
        }

        .stat-line-top {
            font-size: 2.2rem;
            line-height: 0.8;
            color: var(--text-gold);
            opacity: 0.9;
            margin-top: -0.1rem; 
        }

        .stat-line-bottom {
            font-size: 2.2rem;
            line-height: 0.8;
            color: var(--text-gold);
            opacity: 0.9;
            display: flex;
            align-items: baseline;
            justify-content: flex-end;
            margin-bottom: -0.1rem;
        }

        .percent-mark {
            font-size: 1rem;
            margin-right: 0.3rem;
            opacity: 0.8;
            transform: translateY(-4px); 
        }

    </style>
</head>
<body>

    <div id="app-container">
        
        <!-- Header -->
        <header class="text-center pt-4 flex-shrink-0 z-10">
            <h1 class="text-[4rem] text-[#e3d4aa] opacity-90">the moon</h1>
            
            <!-- [数据] 当前月相名称 -->
            <div id="phase-name" class="phase-name text-[#e3d4aa]">--</div>
        </header>
    
        <!-- Compass System (视觉核心) -->
        <div class="compass-wrapper">
            <div class="dial-rotator" id="dial-rotator">
                <div id="arc-container"></div>
                <!-- [数据] 红色指针容器：旋转这个容器来定位指针 -->
                <div id="red-pointer-rotator" class="red-pointer-container">
                     <div class="red-pointer"></div>
                </div>
            </div>
            <div class="viewfinder-static flex justify-center items-center">
                <!-- [数据] 月球视觉 -->
                <div class="moon-visual" id="moon-visual"></div>
            </div>
        </div>
    
        <!-- Timeline (时间轴) -->
        <div class="w-full flex justify-between items-end px-6 mt-2 opacity-90 flex-shrink-0 z-10">
            
            <!-- [数据] 左侧：上一个关键时间点 -->
            <div class="flex flex-col items-center">
                <span id="left-time-label" class="text-[0.6rem] uppercase tracking-widest text-[#8a95a3] mb-1 opacity-70">--</span>
                <span id="left-time-value" class="text-2xl font-light tracking-wide text-[#e3d4aa] leading-none">--:--</span>
            </div>
            
            <!-- [数据] 中间：倒计时 -->
            <span id="moon-status-text" class="text-[0.65rem] text-[#8a95a3] uppercase tracking-[0.2em] mb-1.5 blur-[0.5px] opacity-90">
                Locating...
            </span>
            
            <!-- [数据] 右侧：下一个关键时间点 -->
            <div class="flex flex-col items-center">
                <span id="right-time-label" class="text-[0.6rem] uppercase tracking-widest text-[#8a95a3] mb-1 opacity-70">--</span>
                <span id="right-time-value" class="text-2xl font-light tracking-wide text-[#e3d4aa] leading-none">--:--</span>
            </div>
        </div>
    
        <!-- Footer Stats (底部数据板) -->
        <div class="flex flex-col items-center w-full mb-4 flex-shrink-0 z-10">
            
            <div class="footer-stat-container mb-4">
                <!-- [数据] 月面被照亮的百分比 -->
                <div id="illumination-value" class="big-number-box">--</div>
                
                <div class="stat-text-col">
                    <span class="stat-line-top">can be seen</span>
                    
                    <div class="stat-line-bottom">
                        <span class="percent-mark">%</span>
                        <!-- [数据] 月亮当前的粗略方位 -->
                        <span id="moon-direction-text">at --</span>
                    </div>
                </div>
            </div>

            <!-- [数据] 用户当前位置 -->
            <div id="location-text" class="text-[#e3d4aa] opacity-60 text-lg tracking-wide font-light mb-6">
                Detecting Location...
            </div>
            
            <!-- [数据] 底部名言 -->
            <div id="quote-text" class="text-[#e3d4aa] opacity-40 text-[0.65rem] tracking-widest font-sans text-center max-w-[80%] leading-tight">
                We shall meet in the place where there is no darkness
            </div>
        </div>

    </div>

    <script>
        const arcContainer = document.getElementById('arc-container');
        const dialRotator = document.getElementById('dial-rotator');
        const redPointerRotator = document.getElementById('red-pointer-rotator');
        
        // UI Elements
        const phaseNameEl = document.getElementById('phase-name');
        const leftTimeLabelEl = document.getElementById('left-time-label');
        const leftTimeValueEl = document.getElementById('left-time-value');
        const rightTimeLabelEl = document.getElementById('right-time-label');
        const rightTimeValueEl = document.getElementById('right-time-value');
        const statusTextEl = document.getElementById('moon-status-text');
        const illuminationEl = document.getElementById('illumination-value');
        const directionTextEl = document.getElementById('moon-direction-text');
        const locationEl = document.getElementById('location-text');
        const quoteEl = document.getElementById('quote-text');

        // Compass Generation
        // Generate full 360 degrees
        const step = 5; 
        const numberRadiusPercent = 36; 

        for (let deg = 0; deg < 360; deg += step) {
            const tick = document.createElement('div');
            let type = 'minor';
            let isMajor = false;
            
            if (deg % 90 === 0) { type = 'major'; isMajor = true; } // N, E, S, W
            else if (deg % 30 === 0) type = 'major'; // 30, 60, 120...
            else if (deg % 10 === 0) type = 'medium';

            tick.className = `tick ${type}`;
            tick.style.transform = `translateX(-50%) rotate(${deg}deg)`;
            arcContainer.appendChild(tick);

            // Add numbers or labels for major directions
            if (isMajor || deg % 30 === 0) {
                const num = document.createElement('div');
                num.className = 'dial-number';
                
                let label = deg.toString();
                if (deg === 0) label = 'N';
                if (deg === 90) label = 'E';
                if (deg === 180) label = 'S';
                if (deg === 270) label = 'W';
                
                num.innerText = label; 
                
                const rad = deg * (Math.PI / 180);
                const x = 50 + (numberRadiusPercent * Math.sin(rad));
                const y = 50 - (numberRadiusPercent * Math.cos(rad));
                
                num.style.left = `${x}%`;
                num.style.top = `${y}%`;
                arcContainer.appendChild(num);
            }
        }

        // --- Data Logic ---
        
        let currentLat = 0;
        let currentLng = 0;
        let deviceHeading = 0; // Device compass heading for visibility calculation
        let cloudCoverage = 25; // Cloud coverage percentage (0-100)
        
        // Quotes - Only one English quote as requested
        const quotes = [
            "We shall meet in the place where there is no darkness"
        ];
        quoteEl.innerText = quotes[Math.floor(Math.random() * quotes.length)];

        function formatTime(date) {
            if (!date || isNaN(date)) return '--:--';
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
        }

        function getMoonEventsForDate(date, lat, lng) {
            const times = SunCalc.getMoonTimes(date, lat, lng);
            const events = [];
            if (times.rise) events.push({ type: 'MOONRISE', time: times.rise });
            if (times.set) events.push({ type: 'MOONSET', time: times.set });
            return events;
        }

        // ============================================
        // 改进的可见度计算函数
        // ============================================
        function calculateVisibility(illumination, moonAzimuth, deviceHeading, cloudCoverage) {
            // 1. 基础可见度（月亮被太阳照亮的百分比）
            let baseVisibility = illumination.fraction;
            
            // 2. 角度修正系数（设备朝向与月亮方向的夹角）
            // 计算设备朝向与月亮方向的夹角（0-180度）
            let angleDiff = Math.abs(moonAzimuth - deviceHeading);
            // 处理360度环绕问题
            if (angleDiff > 180) {
                angleDiff = 360 - angleDiff;
            }
            
            // 角度修正函数：
            // 0°（正对）→ 1.0
            // 90°（垂直）→ 0.5
            // 180°（背对）→ 0.0
            // 使用余弦函数平滑插值
            let angleCorrection = Math.cos((angleDiff * Math.PI) / 180);
            // 将 -1 到 1 映射到 0 到 1
            angleCorrection = (angleCorrection + 1) / 2;
            
            // 3. 云量修正系数
            // 云量越高，可见度越低
            // cloudCoverage: 0-100 (0=无云, 100=完全多云)
            let cloudCorrection = 1 - (cloudCoverage / 100);
            // 确保最小值不为0（即使完全多云，也能看到一点点）
            cloudCorrection = Math.max(cloudCorrection, 0.1);
            
            // 4. 综合计算最终可见度
            let finalVisibility = baseVisibility * angleCorrection * cloudCorrection;
            
            // 确保结果在合理范围内
            finalVisibility = Math.max(0, Math.min(1, finalVisibility));
            
            return {
                base: baseVisibility,
                angleCorrection: angleCorrection,
                cloudCorrection: cloudCorrection,
                final: finalVisibility
            };
        }

        function updateMoonData() {
            const now = new Date();
            
            // 1. 基础 Illumination & Phase (always update, even without location)
            const illumination = SunCalc.getMoonIllumination(now);
            const basePhasePercent = Math.round(illumination.fraction * 100);
            
            // Phase Name
            const phase = illumination.phase; 
            let pName = "New Moon";
            if (phase > 0 && phase < 0.25) pName = "Waxing Crescent";
            else if (phase >= 0.25 && phase < 0.5) pName = "Waxing Gibbous"; 
            else if (phase >= 0.48 && phase <= 0.52) pName = "Full Moon";
            else if (phase > 0.5 && phase < 0.75) pName = "Waning Gibbous";
            else if (phase >= 0.75 && phase < 1) pName = "Waning Crescent";
            
            if (Math.abs(phase - 0.25) < 0.02) pName = "First Quarter";
            if (Math.abs(phase - 0.75) < 0.02) pName = "Last Quarter";
            if (Math.abs(phase - 0.0) < 0.02 || Math.abs(phase - 1.0) < 0.02) pName = "New Moon";
            
            phaseNameEl.innerText = pName;

            // 2. 计算改进后的可见度
            let moonAzimuth = 0;
            if (currentLat && currentLng) {
                const pos = SunCalc.getMoonPosition(now, currentLat, currentLng);
                moonAzimuth = (pos.azimuth * (180/Math.PI)) + 180;
            }
            
            // 使用改进的可见度函数
            const visibilityData = calculateVisibility(
                illumination, 
                moonAzimuth, 
                deviceHeading, 
                cloudCoverage
            );
            
            // 显示最终可见度（四舍五入到整数）
            const finalVisibilityPercent = Math.round(visibilityData.final * 100);
            illuminationEl.innerText = finalVisibilityPercent;

            // 3. Times Logic (Past/Future)
            if (currentLat && currentLng) {
                // Get events for yesterday, today, tomorrow to cover all bases
                const yesterday = new Date(now); yesterday.setDate(yesterday.getDate() - 1);
                const tomorrow = new Date(now); tomorrow.setDate(tomorrow.getDate() + 1);

                let events = [
                    ...getMoonEventsForDate(yesterday, currentLat, currentLng),
                    ...getMoonEventsForDate(now, currentLat, currentLng),
                    ...getMoonEventsForDate(tomorrow, currentLat, currentLng)
                ];

                // Sort by time
                events.sort((a, b) => a.time - b.time);

                // Find where 'now' fits
                let prevEvent = null;
                let nextEvent = null;

                for (let i = 0; i < events.length; i++) {
                    if (events[i].time > now) {
                        nextEvent = events[i];
                        prevEvent = events[i - 1];
                        break;
                    }
                }
                
                // Fallback if exact match fails (rare with continuos time)
                if (!nextEvent && events.length > 0) {
                     prevEvent = events[events.length - 1];
                     // Predict next based on prev type (rough)
                }

                // Update Left (Past)
                if (prevEvent) {
                    leftTimeLabelEl.innerText = prevEvent.type;
                    leftTimeValueEl.innerText = formatTime(prevEvent.time);
                }

                // Update Right (Future)
                if (nextEvent) {
                    rightTimeLabelEl.innerText = nextEvent.type;
                    rightTimeValueEl.innerText = formatTime(nextEvent.time);

                    // Update Countdown Status
                    const diffMs = nextEvent.time - now;
                    const diffHrs = Math.floor(diffMs / (1000 * 60 * 60));
                    const diffMins = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
                    
                    // Status Text Logic: "MOON WILL [RISE/SET] IN ..."
                    // type is MOONRISE or MOONSET
                    const action = nextEvent.type === 'MOONRISE' ? 'RISE' : 'SET';
                    
                    let timeString = "";
                    if (diffHrs > 0) {
                        timeString = `${diffHrs}h ${diffMins}m`;
                    } else {
                        timeString = `${diffMins}m`;
                    }
                    statusTextEl.innerText = `MOON WILL ${action} IN ${timeString}`;
                }
                
                // 4. Compass Logic (Red Pointer and Direction Text)
                const pos = SunCalc.getMoonPosition(now, currentLat, currentLng);
                const moonAzimuth = (pos.azimuth * (180/Math.PI)) + 180;
                
                const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
                const dirIndex = Math.round(moonAzimuth / 45) % 8;
                directionTextEl.innerText = `at ${dirs[dirIndex]}`;
                
                // Update Red Pointer Rotation
                if(redPointerRotator) {
                    redPointerRotator.style.transform = `rotate(${moonAzimuth}deg)`;
                }
            } else {
                // 即使没有位置，也更新可见度（只使用基础可见度和角度修正）
                const visibilityData = calculateVisibility(
                    illumination, 
                    0, // 默认方位角
                    deviceHeading, 
                    cloudCoverage
                );
                const finalVisibilityPercent = Math.round(visibilityData.final * 100);
                illuminationEl.innerText = finalVisibilityPercent;
            }
        }

        // Simple cloud coverage estimation (no API needed)
        function estimateCloudCoverage() {
            // Estimate based on time of day and season
            const now = new Date();
            const hour = now.getHours();
            const month = now.getMonth(); // 0-11
            
            // Base estimation: night time typically has clearer skies
            let baseCoverage = 25; // Default 25%
            
            // Time-based adjustment
            if (hour >= 20 || hour < 6) {
                // Night time: clearer skies
                baseCoverage = 15;
            } else if (hour >= 6 && hour < 12) {
                // Morning: moderate clouds
                baseCoverage = 30;
            } else if (hour >= 12 && hour < 18) {
                // Afternoon: more clouds possible
                baseCoverage = 35;
            } else {
                // Evening: clearing
                baseCoverage = 25;
            }
            
            // Seasonal adjustment (rough estimate)
            // Winter months (Nov-Feb) tend to have more clouds
            if (month >= 10 || month <= 1) {
                baseCoverage += 10;
            }
            
            // Add some randomness for realism (±10%)
            const variation = (Math.random() - 0.5) * 20;
            cloudCoverage = Math.max(0, Math.min(100, baseCoverage + variation));
            
            return cloudCoverage;
        }

        // Geolocation
        function initGeo() {
            if ("geolocation" in navigator) {
                navigator.geolocation.getCurrentPosition(async (position) => {
                    currentLat = position.coords.latitude;
                    currentLng = position.coords.longitude;
                    
                    try {
                        // Force English language response
                        const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${currentLat}&lon=${currentLng}&zoom=10&accept-language=en`;
                        const resp = await fetch(url, { headers: { 'User-Agent': 'MoonApp/1.0' } });
                        const data = await resp.json();
                        const city = data.address?.city || data.address?.town || data.address?.village || "Unknown Location";
                        locationEl.innerText = `${city}`;
                    } catch (e) {
                        locationEl.innerText = `${currentLat.toFixed(2)}, ${currentLng.toFixed(2)}`;
                    }

                    // Estimate cloud coverage (no API needed)
                    estimateCloudCoverage();
                    
                    // Update immediately
                    updateMoonData();
                    // Update every 30 seconds for real-time illumination
                    setInterval(updateMoonData, 30000);
                    // Re-estimate cloud coverage every 10 minutes (for time-based changes)
                    setInterval(() => {
                        estimateCloudCoverage();
                        updateMoonData();
                    }, 600000); // 10 minutes
                    
                }, (err) => {
                    locationEl.innerText = "Location Access Denied";
                    console.warn(err);
                    
                    // Estimate cloud coverage even without location
                    estimateCloudCoverage();
                    // Still update moon data even without location
                    updateMoonData();
                    setInterval(updateMoonData, 30000);
                    setInterval(() => {
                        estimateCloudCoverage();
                        updateMoonData();
                    }, 600000);
                });
            } else {
                locationEl.innerText = "Geolocation not supported";
                // Estimate cloud coverage
                estimateCloudCoverage();
                // Still update moon data even without location
                updateMoonData();
                setInterval(updateMoonData, 30000);
                setInterval(() => {
                    estimateCloudCoverage();
                    updateMoonData();
                }, 600000);
            }
        }

        // Device Orientation (Compass)
        function initCompass() {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS 13+ requires permission
                document.body.addEventListener('click', async () => {
                     try {
                        const response = await DeviceOrientationEvent.requestPermission();
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            console.log('Device orientation permission granted');
                        } else {
                            console.warn('Device orientation permission denied');
                        }
                     } catch(e) {
                         console.error('Device orientation permission error:', e);
                     }
                }, { once: true });
            } else {
                // Most Android and desktop browsers don't need permission
                window.addEventListener('deviceorientation', handleOrientation);
                console.log('Device orientation listener added (no permission needed)');
            }
        }

        let lastHeading = null;
        let rafId = null;

        function handleOrientation(event) {
            let heading = 0;
            
            if (event.webkitCompassHeading !== undefined && event.webkitCompassHeading !== null) {
                // iOS Safari provides webkitCompassHeading
                heading = event.webkitCompassHeading;
            } else if (event.alpha !== undefined && event.alpha !== null) {
                // Android and other browsers use alpha
                heading = 360 - event.alpha;
            } else {
                // No valid heading data
                return;
            }
            
            // Update device heading for visibility calculation (always update)
            deviceHeading = heading;
            
            // Cancel previous animation frame if exists
            if (rafId) {
                cancelAnimationFrame(rafId);
            }
            
            // Use requestAnimationFrame for smooth updates
            rafId = requestAnimationFrame(() => {
                // Only update if heading changed significantly (reduce jitter)
                if (lastHeading === null || Math.abs(heading - lastHeading) > 0.5) {
                    dialRotator.style.transform = `rotate(-${heading}deg)`;
                    lastHeading = heading;
                    
                    // Update visibility when device orientation changes
                    updateMoonData();
                }
            });
        }

        // ============================================
        // 可见度函数逻辑简述：
        // ============================================
        // 1. 使用 SunCalc.getMoonIllumination(now) 获取当前时刻的月亮光照数据
        // 2. illumination.fraction 返回 0-1 之间的值，表示月亮被太阳照亮的比例
        //    例如：0.5 = 50% 可见（半月），1.0 = 100% 可见（满月），0.0 = 0% 可见（新月）
        // 3. 将 fraction * 100 并四舍五入，得到百分比显示（如 82%）
        // 4. 这个值会实时更新，因为月亮位置相对于太阳是不断变化的
        // 5. 注意：可见度是全局的，不需要用户位置信息，所以即使没有 GPS 也能显示
        // ============================================

        // Start
        // Initialize cloud coverage estimation
        estimateCloudCoverage();
        // Update moon data immediately (illumination works without location)
        updateMoonData();
        
        // Initialize geolocation and compass - simple direct call like the working version
        initGeo();
        initCompass();
        // Update visibility and phase every 5 seconds for real-time feel
        setInterval(() => {
            const now = new Date();
            const illumination = SunCalc.getMoonIllumination(now);
            
            // Update phase name
            const phase = illumination.phase; 
            let pName = "New Moon";
            if (phase > 0 && phase < 0.25) pName = "Waxing Crescent";
            else if (phase >= 0.25 && phase < 0.5) pName = "Waxing Gibbous"; 
            else if (phase >= 0.48 && phase <= 0.52) pName = "Full Moon";
            else if (phase > 0.5 && phase < 0.75) pName = "Waning Gibbous";
            else if (phase >= 0.75 && phase < 1) pName = "Waning Crescent";
            
            if (Math.abs(phase - 0.25) < 0.02) pName = "First Quarter";
            if (Math.abs(phase - 0.75) < 0.02) pName = "Last Quarter";
            if (Math.abs(phase - 0.0) < 0.02 || Math.abs(phase - 1.0) < 0.02) pName = "New Moon";
            
            phaseNameEl.innerText = pName;
            
            // Update visibility with all corrections
            updateMoonData();
        }, 5000); // Update every 5 seconds for more real-time feel
        
        // Touch scrolling enhancement for mobile
        let touchStartY = 0;
        let touchEndY = 0;
        const appContainer = document.getElementById('app-container');
        
        appContainer.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        }, { passive: true });
        
        appContainer.addEventListener('touchmove', (e) => {
            // Allow native scrolling
        }, { passive: true });
        
        appContainer.addEventListener('touchend', (e) => {
            touchEndY = e.changedTouches[0].clientY;
            // Native scroll will handle it, this is just for potential future enhancements
        }, { passive: true });

    </script>
</body>
</html>