<!DOCTYPE html>
<html>
<head>
    <title>月相计算测试 - 北京、上海、香港</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .city { margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        .result { margin-top: 10px; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
    </style>
</head>
<body>
    <h1>精确月相计算测试</h1>
    <button onclick="runTests()">运行测试（北京、上海、香港、拉萨）</button>
    <button onclick="runRandomTests()">随机时间测试</button>
    <div id="results"></div>

    <script>
        // 复制moonPhaseCalculator.ts的核心函数到JavaScript
        function toJulianDay(date) {
            const year = date.getUTCFullYear();
            const month = date.getUTCMonth() + 1;
            const day = date.getUTCDate();
            const hour = date.getUTCHours();
            const minute = date.getUTCMinutes();
            const second = date.getUTCSeconds();
            
            const decimalDay = day + (hour / 24) + (minute / 1440) + (second / 86400);
            
            let a, b;
            if (month <= 2) {
                const yearAdj = year - 1;
                const monthAdj = month + 12;
                a = Math.floor(yearAdj / 100);
                b = 2 - a + Math.floor(a / 4);
            } else {
                a = Math.floor(year / 100);
                b = 2 - a + Math.floor(a / 4);
            }
            
            const jd = Math.floor(365.25 * (year + 4716)) + 
                       Math.floor(30.6001 * (month + 1)) + 
                       decimalDay + b - 1524.5;
            
            return jd;
        }

        function calculateDaysSinceNewMoon(jd) {
            const k = Math.floor((jd - 2451545) / 29.53058867) + 0.5;
            const t = (jd - 2451545) / 36525;
            
            const jde = 2451545 + 29.53058867 * k;
            
            const e = 1 - 0.002516 * t - 0.0000074 * t * t;
            const m = (134.96340251 + 1717915923.2178 * t / 3600) % 360;
            const m_rad = (m * Math.PI) / 180;
            
            const m_prime = (357.5291092 + 129596581.0481 * t / 3600) % 360;
            const m_prime_rad = (m_prime * Math.PI) / 180;
            
            const f = (93.2720950 + 1739527262.8478 * t / 3600) % 360;
            const f_rad = (f * Math.PI) / 180;
            
            let correction = -0.40720 * Math.sin(m_rad);
            correction += 0.17241 * e * Math.sin(m_prime_rad);
            correction += 0.01608 * Math.sin(2 * m_rad);
            correction += 0.01039 * Math.sin(2 * f_rad);
            correction += 0.00739 * e * Math.sin(m_rad - m_prime_rad);
            correction -= 0.00514 * e * Math.sin(m_rad + m_prime_rad);
            correction += 0.00208 * e * e * Math.sin(2 * m_prime_rad);
            correction -= 0.00111 * Math.sin(m_rad - 2 * f_rad);
            correction -= 0.00057 * Math.sin(m_rad + 2 * f_rad);
            correction += 0.00056 * e * Math.sin(2 * m_rad + m_prime_rad);
            correction -= 0.00042 * Math.sin(3 * m_rad);
            correction += 0.00042 * e * Math.sin(m_prime_rad + 2 * f_rad);
            correction += 0.00038 * e * Math.sin(m_prime_rad - 2 * f_rad);
            correction -= 0.00024 * e * Math.sin(2 * m_rad - m_prime_rad);
            correction -= 0.00017 * Math.sin(m_prime_rad);
            correction -= 0.00007 * Math.sin(m_rad + 2 * m_prime_rad);
            correction += 0.00004 * Math.sin(2 * m_rad - 2 * f_rad);
            correction += 0.00004 * Math.sin(3 * m_prime_rad);
            correction += 0.00003 * Math.sin(m_rad + m_prime_rad - 2 * f_rad);
            correction += 0.00003 * Math.sin(2 * m_prime_rad - 2 * f_rad);
            correction -= 0.00003 * Math.sin(m_rad + m_prime_rad + 2 * f_rad);
            correction += 0.00003 * Math.sin(m_rad - m_prime_rad + 2 * f_rad);
            correction -= 0.00002 * Math.sin(m_rad - m_prime_rad - 2 * f_rad);
            correction -= 0.00002 * Math.sin(3 * m_rad + m_prime_rad);
            
            const newMoonJD = jde + correction;
            
            let daysSinceNewMoon = jd - newMoonJD;
            
            while (daysSinceNewMoon < 0) {
                daysSinceNewMoon += 29.53058867;
            }
            while (daysSinceNewMoon >= 29.53058867) {
                daysSinceNewMoon -= 29.53058867;
            }
            
            return daysSinceNewMoon;
        }

        function calculateMoonIllumination(date) {
            const utcDate = new Date(date.getTime() + (date.getTimezoneOffset() * 60000));
            const jd = toJulianDay(utcDate);
            const daysSinceNewMoon = calculateDaysSinceNewMoon(jd);
            const synodicMonth = 29.53058867;
            const phaseAngle = (2 * Math.PI * daysSinceNewMoon) / synodicMonth;
            const illumination = (1 - Math.cos(phaseAngle)) / 2;
            
            return Math.max(0, Math.min(1, illumination));
        }

        function getMoonPhaseNameFromDate(date) {
            const illumination = calculateMoonIllumination(date);
            const utcDate = new Date(date.getTime() + (date.getTimezoneOffset() * 60000));
            const jd = toJulianDay(utcDate);
            const daysSinceNewMoon = calculateDaysSinceNewMoon(jd);
            const synodicMonth = 29.53058867;
            
            const phase = daysSinceNewMoon / synodicMonth;
            
            if (illumination < 0.01) {
                return "New Moon";
            } else if (phase < 0.0625) {
                return "Waxing Crescent";
            } else if (phase < 0.25) {
                return "Waxing Crescent";
            } else if (phase < 0.375) {
                return "First Quarter";
            } else if (phase < 0.5) {
                return "Waxing Gibbous";
            } else if (phase < 0.625) {
                return "Full Moon";
            } else if (phase < 0.75) {
                return "Waning Gibbous";
            } else if (phase < 0.875) {
                return "Last Quarter";
            } else {
                return "Waning Crescent";
            }
        }

        function formatLocalTime(date, timezoneOffset) {
            // 获取UTC时间戳
            const utcTimestamp = date.getTime();
            // 加上时区偏移
            const localTimestamp = utcTimestamp + (timezoneOffset * 3600000);
            const localDate = new Date(localTimestamp);
            
            // 手动格式化，避免toLocaleString的时区转换
            const year = localDate.getUTCFullYear();
            const month = String(localDate.getUTCMonth() + 1).padStart(2, '0');
            const day = String(localDate.getUTCDate()).padStart(2, '0');
            const hours = String(localDate.getUTCHours()).padStart(2, '0');
            const minutes = String(localDate.getUTCMinutes()).padStart(2, '0');
            const seconds = String(localDate.getUTCSeconds()).padStart(2, '0');
            
            return `${year}/${month}/${day} ${hours}:${minutes}:${seconds}`;
        }

        const cities = [
            { name: "北京", lat: 39.9042, lon: 116.4074, timezone: 8 },
            { name: "上海", lat: 31.2304, lon: 121.4737, timezone: 8 },
            { name: "香港", lat: 22.3193, lon: 114.1694, timezone: 8 },
            // ========== 模拟测试数据 - 拉萨 ==========
            // TODO: 删除标记 - 这是用于测试的模拟数据，正式版本需要删除
            { name: "拉萨", lat: 29.6626, lon: 91.1160, timezone: 8 },
            // ========== 模拟测试数据结束 ==========
        ];

        function runTests() {
            const now = new Date();
            const resultsDiv = document.getElementById('results');
            let html = '<h2>测试结果</h2>';
            html += `<p>测试时间 (UTC): ${now.toISOString()}</p>`;
            html += `<p><strong>注意：月相照明度是全球统一的（基于UTC时间），但月升月落时间会因地理位置不同而不同</strong></p>`;
            
            cities.forEach(city => {
                // 月相计算应该使用UTC时间（全球统一）
                const utcTime = new Date(now);
                const illumination = calculateMoonIllumination(utcTime);
                const phaseName = getMoonPhaseNameFromDate(utcTime);
                
                html += `
                    <div class="city">
                        <h3>${city.name}</h3>
                        <p>坐标: ${city.lat}°N, ${city.lon}°E</p>
                        <p>UTC时间: ${utcTime.toISOString()}</p>
                        <p>本地时间: ${formatLocalTime(now, city.timezone)}</p>
                        <div class="result">
                            <strong>月相照明度: ${(illumination * 100).toFixed(2)}%</strong><br>
                            <strong>月相名称: ${phaseName}</strong>
                            <p style="color: #666; font-size: 12px;">* 月相照明度全球统一，与地理位置无关</p>
                        </div>
                    </div>
                `;
            });
            
            resultsDiv.innerHTML = html;
        }

        function runRandomTests() {
            const resultsDiv = document.getElementById('results');
            let html = '<h2>随机时间测试结果</h2>';
            html += `<p><strong>注意：月相照明度是全球统一的（基于UTC时间），但月升月落时间会因地理位置不同而不同</strong></p>`;
            
            // 生成3个随机时间（过去30天内）
            const randomTimes = [];
            for (let i = 0; i < 3; i++) {
                const randomDaysAgo = Math.random() * 30;
                const randomTime = new Date(Date.now() - randomDaysAgo * 24 * 60 * 60 * 1000);
                randomTimes.push(randomTime);
            }
            
            randomTimes.forEach((testTime, index) => {
                html += `<h3>测试时间 ${index + 1}: ${testTime.toISOString()} (UTC)</h3>`;
                
                cities.forEach(city => {
                    // 月相计算应该使用UTC时间（全球统一）
                    const utcTime = new Date(testTime);
                    const illumination = calculateMoonIllumination(utcTime);
                    const phaseName = getMoonPhaseNameFromDate(utcTime);
                    
                    html += `
                        <div class="city">
                            <h4>${city.name}</h4>
                            <p>坐标: ${city.lat}°N, ${city.lon}°E</p>
                            <p>UTC时间: ${utcTime.toISOString()}</p>
                            <p>本地时间: ${formatLocalTime(testTime, city.timezone)}</p>
                            <div class="result">
                                <strong>月相照明度: ${(illumination * 100).toFixed(2)}%</strong><br>
                                <strong>月相名称: ${phaseName}</strong>
                                <p style="color: #666; font-size: 12px;">* 月相照明度全球统一，与地理位置无关</p>
                            </div>
                        </div>
                    `;
                });
            });
            
            resultsDiv.innerHTML = html;
        }

        // 页面加载时自动运行一次测试
        window.onload = runTests;
    </script>
</body>
</html>

